#!/bin/bash
#PBS -l nodes=1:ppn=16,walltime=4:00:00
#PBS -l vmem=31gb
#PBS -N tractoflow
#PBS -V

set -e
set -o pipefail

# === CONFIGURATION ===
SUBJECT_ID="S1"
INPUT_ROOT="data/input"
OUTPUT_ROOT="data/output"
MINICONDA_VERSION="latest"
INSTALL_DIR="$HOME/miniconda3"
CONDA_ENV_NAME="tractoflow"
NEXTFLOW_VERSION="21.10.6"
SCIL_IMAGE="scilus_1.6.0.sif"
TRACTOFLOW_REPO="tractoflow"
LOG_DIR="../logs_$(date +%Y%m%d_%H%M%S)"

# === INPUT PARSING ===
dwi=$(jq -r '.dwi' config.json)
bvals=$(jq -r '.bvals' config.json)
bvecs=$(jq -r '.bvecs' config.json)
t1w=$(jq -r '.t1' config.json)

# === CREATE INPUT STRUCTURE ===
mkdir -p "$INPUT_ROOT/$SUBJECT_ID"
cp "$dwi"   "$INPUT_ROOT/$SUBJECT_ID/dwi.nii.gz"
cp "$bvals" "$INPUT_ROOT/$SUBJECT_ID/bval"
cp "$bvecs" "$INPUT_ROOT/$SUBJECT_ID/bvec"
cp "$t1w"   "$INPUT_ROOT/$SUBJECT_ID/t1.nii.gz"

# === PREP OUTPUT STRUCTURE ===
mkdir -p "$OUTPUT_ROOT" Resample_DWI Resample_T1 PFT_Tracking "$LOG_DIR"

# === INSTALL MINICONDA (IF NEEDED) ===
if [ ! -d "$INSTALL_DIR" ]; then
    echo "üì¶ Installing Miniconda..."
    INSTALLER="Miniconda3-$MINICONDA_VERSION-Linux-x86_64.sh"
    wget -O miniconda.sh "https://repo.anaconda.com/miniconda/$INSTALLER"
    bash miniconda.sh -b -p "$INSTALL_DIR"
    rm miniconda.sh
fi

# === LOAD CONDA ===
source "$INSTALL_DIR/etc/profile.d/conda.sh"

# === ACCEPT TOS IF SUPPORTED ===
if conda tos --help &> /dev/null; then
    conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/main
    conda tos accept --override-channels --channel https://repo.anaconda.com/pkgs/r
else
    echo "‚ÑπÔ∏è 'conda tos' not supported. Skipping."
fi

# === CREATE CONDA ENV (IF NEEDED) ===
if ! conda env list | grep -q "$CONDA_ENV_NAME"; then
    echo "üîß Creating Conda env: $CONDA_ENV_NAME"
    conda create -n "$CONDA_ENV_NAME" -y
    conda activate "$CONDA_ENV_NAME"
    conda install -y -c bioconda nextflow="$NEXTFLOW_VERSION"
else
    conda activate "$CONDA_ENV_NAME"
fi

# === FIX openjdk unbound variable error ===
JDK_ACTIVATE="$INSTALL_DIR/envs/$CONDA_ENV_NAME/etc/conda/activate.d/openjdk_activate.sh"
if [ -f "$JDK_ACTIVATE" ]; then
    sed -i '1s|^|JAVA_HOME={JAVA_HOME:-}\n|' "$JDK_ACTIVATE"
fi

# === EXPORT PATH FOR SAFETY ===
export PATH="$INSTALL_DIR/envs/$CONDA_ENV_NAME/bin:$PATH"

# === PULL SINGULARITY IMAGE ===
if [ ! -f "$SCIL_IMAGE" ]; then
    singularity pull --name "$SCIL_IMAGE" docker://scilus/scilus:1.6.0
fi

# === CLONE TRACTOFLOW (IF NEEDED) ===
if [ ! -d "$TRACTOFLOW_REPO" ]; then
    git clone https://github.com/scilus/tractoflow.git "$TRACTOFLOW_REPO"
fi

cd "$TRACTOFLOW_REPO"

# === FIX CONFIG FOR HOME ISSUE ===
sed -i '/singularity\.runOptions/d' nextflow.config
echo 'singularity.runOptions = "--home \${baseDir}"' >> nextflow.config

# === ENSURE SINGULARITY IS VISIBLE TO NEXTFLOW JOBS ===
SINGULARITY_PATH=$(which singularity)
if [[ -z "$SINGULARITY_PATH" ]]; then
    echo "‚ùå Error: singularity not found in PATH."
    exit 1
fi
export NXF_SINGULARITY_CLI="$SINGULARITY_PATH"
echo "‚úÖ Singularity detected at: $SINGULARITY_PATH"

export NXF_SINGULARITY_CLI="/usr/bin/singularity"

# === RUN TRACTOFLOW WITH LOGGING ===
nextflow run ./main.nf \
    --input ../"$INPUT_ROOT" \
    -with-singularity ../"$SCIL_IMAGE" \
    --output_dir ../"$OUTPUT_ROOT" \
    --processes 16 \
    -with-trace "$LOG_DIR/trace.txt" \
    -with-report "$LOG_DIR/report.html" \
    -with-timeline "$LOG_DIR/timeline.html" \
    -with-dag "$LOG_DIR/flowchart.png" || {
        echo "‚ùå Pipeline failed. Check $LOG_DIR/*.log"
        cp .nextflow.log "$LOG_DIR/nextflow.log"
        exit 1
    }

cp .nextflow.log "$LOG_DIR/nextflow.log"

# === COLLECT PER-JOB COMMAND LOGS INTO A CENTRAL LOG ===
echo "üìù Aggregating command stdout/stderr logs into ./logs/command_logs.txt"
mkdir -p "$LOG_DIR"
LOG_FILE="$LOG_DIR/command_logs.txt"
WORK_DIR="../$OUTPUT_ROOT/work"

echo "== TractoFlow Command Logs ==" > "$LOG_FILE"

# Iterate through each work directory
find "$WORK_DIR" -type f -name ".command.out" | while read -r out_file; do
    job_dir=$(dirname "$out_file")
    err_file="$job_dir/.command.err"

    echo -e "\n\n========== $job_dir ==========" >> "$LOG_FILE"

    if [ -s "$out_file" ]; then
        echo -e "\n--- STDOUT ---" >> "$LOG_FILE"
        cat "$out_file" >> "$LOG_FILE"
    fi

    if [ -s "$err_file" ]; then
        echo -e "\n--- STDERR ---" >> "$LOG_FILE"
        cat "$err_file" >> "$LOG_FILE"
    fi
done

echo "‚úÖ Log summary saved to $LOG_FILE"



# === COPY OUTPUTS ===
cp ../"$OUTPUT_ROOT"/Resample_DWI/*__dwi_resampled.nii.gz ../Resample_DWI/dwi.nii.gz || echo "‚ö†Ô∏è Missing dwi.nii.gz"
cp ../"$OUTPUT_ROOT"/Extract_FODF_Shell/*__bval_fodf ../Resample_DWI/dwi.bvals || echo "‚ö†Ô∏è Missing bval"
cp ../"$OUTPUT_ROOT"/Extract_FODF_Shell/*__bvec_fodf ../Resample_DWI/dwi.bvecs || echo "‚ö†Ô∏è Missing bvec"
cp ../"$OUTPUT_ROOT"/Resample_T1/*__t1_resampled.nii.gz ../Resample_T1/t1.nii.gz || echo "‚ö†Ô∏è Missing t1"
cp ../"$OUTPUT_ROOT"/PFT_Tracking/*__pft_tracking_prob_wm_seed_0.trk ../PFT_Tracking/track.trk || echo "‚ö†Ô∏è Missing track.trk"

echo "‚úÖ TractoFlow pipeline completed."
echo "üìù Logs available in: $LOG_DIR"
